---
layout: post
title: 《程序员的自我修养》读书笔记（1）
categories:
- Reading
---

嘛，最近在阅读[《程序员的自我修养》](https://book.douban.com/subject/3652388/)。如果当时大三学OS时候能读这本书的话，真的超棒。

![](http://oiqcl4y9s.bkt.clouddn.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.png)

先总结第一章吧，温故而知新，介绍基本的背景知识，包括硬件、操作系统、线程等

站在软件开发者的角度看，计算机硬件最为关键有：中央处理器CPU、内存和I/O控制芯片

![](http://oiqcl4y9s.bkt.clouddn.com/%E6%97%A9%E6%9C%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84.png)

早期计算机硬件直接连接在同一个[总线Bus](http://baike.baidu.com/link?url=XK2cRwGbyftOFf7V7WhFHIcyBNOEeI23MYuTdBDG5Y5NqfxhVZTxsNTPC2aaP1KJzx8allkcRhRZfX8oRLb3pmcwkEkjegYM7Njou3EQ-Tq)上。随着图像化操作系统特别是3D游戏发展，图形芯片需要跟CPU和内存之间大量交换数据。为了协调CPU、内存和高速图形设备，人们设计了高速北桥芯片，以便高速交换数据。又专门设计了处理低速设备的南桥芯片，磁盘、USB、键盘、鼠标等连接在南桥上，由南桥汇总后连接到北桥上。

![](http://oiqcl4y9s.bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)

每个层次之间都须要相互通信，既然须要通信就必须有一个通信的协议，我们一般将其称为接口（Interface）。接口精心设计，理论上层次之间只要遵化接口，任何一个层都可以被修改或替换。

比如：操作系统内核对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口定义决定了操作系统内核，具体来讲就是驱动程序如何操作硬件，如何与硬件通信。

#### 操作系统

操作系统的一个功能是提供抽象的接口，另外一个功能是管理硬件资源。OS挖掘CPU、存储器（CPU和磁盘）以及I/O三种主要硬件设备的资源。

期初的多道程序会监视CPU，当某个程序暂时无须使用CPU时，监控程序把另外正在等待CPU的程序启动起来，大大提高了CPU的利用率。但原始的多道程序技术存在调度策略粗糙的问题，不分任务的轻重缓急。稍经改进，程序运行模式变成了一种协作的模式，每个程序运行一段时间都主动让出CPU，使得一段时间内每个程序都有机会运行一小段时间。这种程序协作模式叫做分时系统（Time-Sharing System）。倘若系统中任何一个程序死循环都会导致系统死机，这种分时方式勉强应付简单的交互式环境。后来研究出更为先进的模式：多任务系统。操作系统接管了所有硬件资源，所有应用程序都以进程的方式运行在比OS权限更低的级别，每个进程都有自己独立的地址空间，使得进程之间地址空间相互隔离。CPU由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到CPU，但是，如果运行时间超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他等待运行的进程。这种CPU的分配方式即所谓的抢占式（Preemptive），操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。如果操作系统分配给每个进程的时间都很短，即CPU在多个进程间快速地切换，从而造成了很多进程都在同时运行的假象。目前几乎所有现代的操作系统都是采用这种方式。

成熟的操作系统出现以后，硬件逐渐被抽象成了一系列概念。对于操作系统上面的运行库和应用程序来说，它们看到的是一个统一的硬件访问模式。程序员逐渐从硬件细节中解放出来，可以更多地关注应用程序本身的开发。

#### 内存分配

在早期的计算机中，程序是直接运行在物理内存上的，也就是说，程序在运行时所访问的地址都是物理地址。那么，如何将计算机上有限的物理内存分配给多个程序使用？

需要解决的问题有很多：

- 所有程序都直接访问物理地址，由于地址空间不隔离，恶意程序可以很容易修改其他程序的内存数据；
- 内存空间大小的局限性，监控程序往往将整个程序装入内存后开始执行。如果我们忽然需要运行程序C，那么这时内存空间其实已经不够了，这时候我们可以用的一个办法是将其他程序的数据暂时写到磁盘里面，等到需要用到的时候再读回来；
- 程序运行地址的不确定，每次给程序分配的内存区域位置是不确定的，这给程序的编写造成麻烦。

通过把程序给出的地址看作是一种虚拟地址（Virtual Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。这样，只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能够访问的物理内存区域跟另外一个程序相互不重叠，以达到地址空间隔离的效果。

那么如何控制这个映射？分段和分页。

分段的基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。

